package com.vio_0x.methodic.viewmodel

import android.app.Application
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import com.vio_0x.methodic.data.AppDatabase
import com.vio_0x.methodic.data.TaskFilter
import com.vio_0x.methodic.data.TaskPriority
import com.vio_0x.methodic.data.ToDoItem
import com.vio_0x.methodic.data.ToDoItemDao
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import java.util.Date

class TaskListViewModel(application: Application) : AndroidViewModel(application) {

    private val dao: ToDoItemDao = AppDatabase.getDatabase(application).todoItemDao()

    private val _uiState = MutableStateFlow(TaskListUiState())

    // Flow of all items from the database
    private val _allItems: StateFlow<List<ToDoItem>> = dao.getAllItems()
        .stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000L), // Keep flow active 5s after last subscriber
            initialValue = emptyList()
        )

    // Combined state including items from DB and UI settings
    val combinedState: StateFlow<Pair<TaskListUiState, List<ToDoItem>>> =
        combine(_uiState, _allItems) { ui, items ->
            Pair(ui, items)
        }.stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000L),
            initialValue = Pair(TaskListUiState(), emptyList())
        )


    // --- Events / Actions ---

    fun updateNewTaskText(text: String) {
        _uiState.update { it.copy(newTaskText = text) }
    }

    fun updateNewTaskDescription(description: String) {
        _uiState.update { it.copy(newTaskDescription = description) }
    }

    fun updateNewTaskPriority(priority: TaskPriority) {
        _uiState.update { it.copy(newTaskPriority = priority) }
    }

    fun showAddTaskSheet() {
        _uiState.update { it.copy(showAddSheet = true) }
    }

    fun hideAddTaskSheet() {
        // Reset fields when hiding the sheet explicitly
        _uiState.update {
            it.copy(
                showAddSheet = false,
                newTaskText = "",
                newTaskDescription = "",
                newTaskPriority = TaskPriority.MEDIUM
            )
        }
    }

    fun addTask() {
        val currentState = _uiState.value // Get current state for text, desc, priority
        if (currentState.newTaskText.isBlank()) {
            return // Don't add empty tasks
        }
        val newItem = ToDoItem(
            // id is auto-generated by Room
            text = currentState.newTaskText,
            description = currentState.newTaskDescription.takeIf { it.isNotBlank() },
            priority = currentState.newTaskPriority,
            createdAt = Date()
            // isCompleted defaults to false, completedAt to null, tags to emptyList
        )
        viewModelScope.launch(Dispatchers.IO) { // Use IO dispatcher for DB operations
            dao.insertItem(newItem)
        }
        // Reset add sheet fields & hide sheet in UI state
        _uiState.update {
            it.copy(
                newTaskText = "",
                newTaskDescription = "",
                newTaskPriority = TaskPriority.MEDIUM,
                showAddSheet = false
            )
        }
    }

    // addTaskFromItem is removed as items are now managed by the database

    fun reinsertItem(item: ToDoItem) {
        viewModelScope.launch(Dispatchers.IO) {
            dao.insertItem(item) // Use insert which handles conflicts if needed
        }
    }

    fun toggleTaskCompletion(item: ToDoItem) { // Pass the whole item for easier update
        viewModelScope.launch(Dispatchers.IO) {
            val updatedItem = item.copy(
                isCompleted = !item.isCompleted,
                completedAt = if (!item.isCompleted) Date() else null
            )
            dao.updateItem(updatedItem)
        }
        // No need to update _uiState.items, the Flow will emit the change
    }

    fun deleteTask(itemId: Int) {
        viewModelScope.launch(Dispatchers.IO) {
            dao.deleteItemById(itemId)
        }
        // No need to update _uiState.items, the Flow will emit the change
    }

    fun setFilter(filter: TaskFilter) {
        _uiState.update { it.copy(filter = filter) }
    }

    fun toggleShowCompleted() {
        _uiState.update { it.copy(showCompleted = !it.showCompleted) }
    }
}